---
layout:     post
title:      笔试知识点总结
subtitle:   笔试错误和知识点总结
date:       22020-04-06
author:     王鹏程
header-img: img/post-bg-ios10.jpg
catalog: true
tags:
    - 笔试笔记
    - 后台开发
    - 找工作
---



## 1. 2020-04-06 网易2020校招笔试- 运维工程师（正式批）

- [网易2020校招笔试- 运维工程师（正式批）](https://www.nowcoder.com/test/question/analytic?tid=32335143)

## 1.1 IP数据报的分片

- [IP分片与重组详解](https://www.cnblogs.com/qiaoyanlin/p/9356119.html)

- 分片在源主机和中间路由器都有可能产生，片到达目的主机后再进行重新组装
- 在TCP/IP分层中，数据链路层用MTU来限制所能传输的数据包大小。MTU是指一次传送的数据最大长度，不包括数据链路层数据帧的帧头。当发送的[IP数据报](https://www.baidu.com/s?wd=IP数据报&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的大小超过了MTU时，IP层就需要对数据进行分片，否则数据将无法发送成功。
- IP分片发生在IP层，不仅源端主机会进行分片，中间的路由器也有可能分片，因为不同网络的MTU是不一样的。如果传输路径上的某个网络的MTU比源端网络的MTU要小，路由器就可能对[IP数据报](https://www.baidu.com/s?wd=IP数据报&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)再次进行分片。而分片数据的重组只会发生在目的端的IP层。
- IP层是没有超时重传机制的。如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大。由此可见，IP分片会大大降低传输层传送数据的成功率，所以要避免IP分片。



## 1.2 子网掩码问题

某高校计算机学院要新建3个实验室,每个实验室有25台主机,已申请了一个C类地址192.168.10.0,该C类地址的子网掩码为（**255.255.255.224**）

- 解析: 因为有3个实验室，就需要3个网段，2^2=4，所以最少需要从地址位借2位，也可以借3位，借4位等等；但由于每个实验室有25台主机，2^4-2=14，2^5-2=30，所以最少需要5位主机位，综合起来，就只能从地址借2-3位了，借2位的话，子网掩码是255.255.255.192，借3位的话，子网掩码是255.255.255.224
- Python 使用_init_()作为构造方法
  - 在继承中基类的构造方法不会被自动调用，需要在派生类的构造方法中显式调用
- init.d是linux7.0之前首先启动的进程，在rhel7.0之后的版本首先启动的是systemd。



## 1.3 (umask 022;touch a) 等价于 （touch a; chmod 644）

- 解析:umask表示反码；因该时默认权限值减去022，因为创建目录时默认最高值为7，创建文件时默认最高值为6，因此最终实际值为666-022=644(rw-r-r)

## 1.4 常用的负载均衡有哪些





## 2. 2020-04-07 网易2020校招笔试- C 开发工程师（正式批/提前批）

## 2.1 在linux 中，设文件F1 的当前引用计数为1，先建立F1 的符号链接文件F2，再建立F1 的硬链接文件 F3，则此时文件F1、F2 和F3 的引用计数值分别是（2,1,2） 。

- [题目链接](https://www.nowcoder.com/questionTerminal/7a63b184d7d74ebebcff64ce929776e8?orderByHotValue=1&page=1&onlyReference=false)
- 解析:
  - [答案](https://www.nowcoder.com/questionTerminal/7a63b184d7d74ebebcff64ce929776e8?orderByHotValue=1&page=1&onlyReference=false)
  - F1是某文件的文件名，F2、F3都是该文件的别名，他们都对应唯一个物理空间，系统中还维护了一个数据结构（UNIX为inode），其中有一数据项为count记录共享该文件的目录数，建立文件时count=1，
  - 每建立一个硬链接count++，建立软链接count值不变，
  - 删除F1前count=2，删除F1后，count- -，
  - 虽然文件主删除了指向该物理文件的链接，但仍有一个硬链接（F3的链接）指向该文件物理空间，此时count=1，
  - 软链接的count值也就是这个count值，因此也是1。直到count=0时，系统才释放该文件的物理空间。
  - (就是：软连接不变，硬链接加1，删除时软硬都减1，当count=0时，文件才真正被删除)
  - 软连接是纯粹的快捷方式，它是一个简单文件，指向源文件。源文件删除，软连接错误。
  - 可以使用`stat`查看文件详细信息



## 2.2 一棵二叉树有8个度为2的节点，5个度为1的节点，那么度为0的节点个数为(9)?

- [链接](https://www.nowcoder.com/test/question/done?tid=32358339&qid=800691#summary)

- 解析: 任一棵树中，结点总数=度数+1

  n0+5+8=（n0*0+1*5+8*2）+1

  n0=9

## 2.3 电子邮件系统中，用户代理把邮件发往发送发邮件服务器、发送方邮件服务器把邮件发往接收方邮件服务器以及用户使用用户代理从接收方邮件服务器上读取邮件时，使用的协议可能是以下的（SMTP、SMTP、IMAP）情形

- [链接](https://www.nowcoder.com/test/question/done?tid=32358339&qid=800673#summary)
- 解析：
  - SMTP：发件人用户代理 ----发送邮件---> 发送方邮件服务器；
    -  发送方邮件服务器 ----发送邮件---> 接收方邮件服务器
  - POP3/IMAP：接受方邮件服务器----读取邮件---> 收件人用户代理

## 2.4 有A、B、C、D 4个类，运行下面的程序，A、B、C、D 4个类的构造函数调用顺序是（B->D->A->C）

```c++
B b;  
int main()  
{  
    D *d = new D();  
    A a;  
    static C c;  
    delete d;  
  
    return 0;  
}  
```



- [链接](https://www.nowcoder.com/test/question/done?tid=32358339&qid=800694#summary)
- 解析:静态局部变量初始化是在第一次调用函数的时候初始化，全局变量是在main之前  



## 2.5 inline 函数的作用

- 场景：当频繁调用小函数时，为了节省函数调用的开销，可以用内联函数
- 注意：inline修饰函数的时候要加上函数体，不然没有用。
- 优点：
  - 执行的速度快
  - 调用时候会检查参数类型，比较安全
  - 可以用来修饰保护成员和私有成员
  - （类中定义的函数不管加不加inline都会是内联函数）
- 缺点：
  - 以函数复制为代价，如果过多使用，会消耗内存
  - 如果函数体内有循环，那么执行函数代码的时间比调用要开销大
  - 是否内联，程序员不可控。inline只是对编译器的建议，是否内联取决于编译器。
- 注意:inline是在编译器将函数类容替换到函数调用处，是静态编译的。而虚函数是动态调用的，在编译器并不知道需要调用的是父类还是子类的虚函数，所以不能够inline声明展开，所以编译器会忽略.因此inline不能修饰虚函数